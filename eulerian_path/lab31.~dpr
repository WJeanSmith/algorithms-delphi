program lab32;
{Выполнил Деревяго А. С.
Реализуйте алгоритм поиска эйлерова пути в графе.}

{$APPTYPE CONSOLE}
Uses
  SysUtils;

Type
  uk = ^steck;
  steck = record
    data: integer;
    next: uk;
  end;

Var
  uk1, uk2: uk;
  n, i, j, x, v, u: integer;
  c : array [1..20] of byte; // массив степеней вершин
  m : array [1..20, 1..20] of boolean ; //массив смежности

function Rus(mes: string):string;
var
  i: integer;
begin
  for i:=1 to length(mes) do
   case mes[i] of
     'А'..'о':mes[i] := Chr(Ord(mes[i]) - 64);
     'п'..'я': mes[i]:= Chr (Ord(mes [i] ) -16);
   end;
  rus := mes;
end;

{чтение файла}
procedure MatrixInput;
var
  matrix : textfile; 
  i, j : integer;
  a, b : byte;
begin
  assign(matrix, 'input.txt');
  reset(matrix);
  readln(matrix, n); //считывем количество вершин
  writeln(rus('Введенная матрица смежности: '));
  a := 1;
  for i:=1 to n do
  begin
    write(a, '  ');
    inc(a);
    for j:=1 to n do 
    begin
      read(matrix, b);
      write(b, ' ');
      if b = 1 then // если элемент матрицы равен 1
        m[i,j]:=true  // заносим в массив значение True
      else 
        m[i,j]:=false;
    end;
    writeln;
  end;
  close(matrix);
end;

{чтение головного элемента}
Function PeekStek(top: uk): integer;
Begin
  result:=top^.data
End;

{добавление нового элемента} 
Procedure PushStek(x: integer; var top: uk);
Var
  vsp: uk;
Begin
  New(vsp);
  vsp^.data:=x;
  vsp^.next:=top;
  top:=vsp;
End;

{удаление элемента}
Procedure PopStek(var x: integer; var top: uk);
Begin
  x:=top^.data;
  top:=top^.next
End;

{печать} 
Procedure PrintStek(l: uk; counter : integer);
var
  res: string;
Begin
  if l = nil then //если стек пуст
  begin
    writeln(rus('Ошибка.')); //ошибка
  end;
  if counter = 0 then
    write(rus('Существует и Эйлеров цикл, и Эйлеров Путь: '))
  else
    write(rus('Эйлеров Путь: '));
  While l <> nil do
  Begin
    res := res + IntToStr(l^.data) + '-'; //выводим содержимое стека
    l:=l^.next;
  end;
  delete(res, length(res), length(res));  //удалим последний "-"
  writeln(res);
  readln;
End;

var
  counter: integer;
{головная программа}
Begin
  matrixinput;
  v:=1;
  counter:=0;
  for i:=1 to N do
  begin
    c[i]:=0;
    for j:=1 to N do 
      if m[i,j] = True then
        inc(c[i]);    //находим степень вершин
  end;
  for i:=1 to n do
  begin
    if c[i] mod 2 <> 0 then  //если есть такие 2 вершины
    begin
      inc(counter);        //степень которых нечетна
      v:=i;     //то есть Эйлеров путь
    end;
  end;
  if counter = 0 then //если нет вершин с нечетной степенью, тогда
    v:=1              // граф имеет и путь, и цикл; отсчет начинается с 1
  else if (counter <> 2) and (counter <> 0) then
  begin
    writeln(rus('Данный граф не содержит Эйлерова Пути'));
    readln;
    exit;
  end;
  uk1:=nil;
  uk2:=nil;
  if (v <= n) then
    PushStek(v, uk1); // в стек кладем вершину
  While uk1 <> NIL do //пока стек не пуст
  Begin
    v:=PeekStek(uk1); //v значение на вершине стека
    i:=1;
    While (i <= n) and not m[v,i] do
      inc(i);
    If i <= n then
    Begin
      u:=i;
      PushStek(u, uk1); //добавляем к ответу
      m[v,u]:=False; // снимаем v с вершины стека
      m[u,v]:=False;
    End
    else // иначе
    Begin
      PopStek(x, uk1); // находим ребро выходящее из v и удаляем его
      PushStek(x, uk2); // второй конец ребра кладем в стек
    End;
  End;
  PrintStek(uk2, counter);
End.
